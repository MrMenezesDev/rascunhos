<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Prova de Conceito Pyscript + P5.JS</title>
  <!-- PyScript CSS -->
  <script src="enable.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@pyscript/core@0.4.32/dist/core.css" />
  <script type="module" src="https://cdn.jsdelivr.net/npm/@pyscript/core@0.4.32/dist/core.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>


  <py-config>
    autoclose_loader = true
    runtimes = [
    { src = "https://cdn.jsdelivr.net/pyodide/alpha/full/pyodide.js", name = "pyodide-alpha", lang = "python" },
    ]
  </py-config>
</head>

<body>
  <script>
    function setup() { }
  </script>

  <script type="py-editor" config='config.json'>
    import p5script as py5

    hex_grid = None


    def settings():
        py5.size(512 + 256, 512)  # Defina o tamanho da tela


    def setup():
        global hex_grid
        col = 10
        row = 5
        grid = HexGrid(cols=col, rows=row, size=50, draw_vertex=draw_vertex, draw_map=draw_map)
        grid.draw()
        hex_grid = HexWaveFunctionCollapseGrid(
            dim=[col, row], draw_cell=grid.draw_cell, border=True
        )
        hex_grid.start()


    def draw():
        global hex_grid
        hex_grid.collapse()
        hex_grid.draw()
        if hex_grid.complete:
            py5.no_loop()

            
    import math

    def get_rotation_in_line(x1, y1, x2, y2, angle):

        # Vetor AB (de A para B)
        AB_x = x2 - x1
        AB_y = y2 - y1

        # Ângulo de rotação (30 graus convertidos para radianos)
        angulo_radianos = math.radians(angle)

        # Matriz de rotação
        cos_theta = math.cos(angulo_radianos)
        sin_theta = math.sin(angulo_radianos)

        # Vetor AC (rotacionado)
        AC_x = cos_theta * AB_x - sin_theta * AB_y
        AC_y = sin_theta * AB_x + cos_theta * AB_y

        # Coordenadas do ponto C
        x_C = x1 + AC_x
        y_C = y1 + AC_y

        return x_C, y_C

    def line_intersection(x1, y1, x2, y2, x3, y3, x4, y4):
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if denom == 0:
            return None  # Linhas são paralelas
        px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom
        py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom
        return px, py

    def draw_vertex(vertexs, color):
        py5.no_stroke()
        py5.begin_shape()
        py5.fill(color)
        for x, y in vertexs:
            py5.vertex(x, y)
        py5.end_shape(py5.CLOSE),


    def draw_map(vertexs, color):
        py5.begin_shape()
        py5.stroke(0)
        py5.stroke_weight(1)
        py5.fill(color)
        for vx, vy in vertexs:
            py5.vertex(vx, vy)
        py5.end_shape(py5.CLOSE)

    import math
    from dataclasses import dataclass, field
    from typing import List, Callable, Tuple

    @dataclass
    class HexGrid:
        cols: int
        rows: int
        size: float
        draw_vertex: Callable
        draw_map: Callable
        colors: List[str] = field(default_factory=lambda: ["#666666", "#999999", "#333333"])
        cells: List = field(default_factory=list)
        hex_height: float = field(init=False)
        hex_width: float = field(init=False)
        offset: float = field(init=False)
        state: List[List[int]] = field(default_factory=list)

        def __post_init__(self):
            self.hex_height = math.sin(math.pi * 2 / 6) * self.size * 2  # Altura do hexágono
            self.hex_width = self.size * 1.5  # Largura do hexágono
            self.offset = self.size
        
            self.state = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        
        def set_state(self, evolution_history, step):
            """
            Define o estado das células com base no evolution_history e no passo atual.
            """
            self.state = evolution_history[step]


        def calculate_center(self, col: int, row: int) -> Tuple[float, float]:
            """
            Calcula o centro do hexágono baseado na coluna e linha.
            """
            offset_y = self.hex_height / 2 if col % 2 == 1 else 0
            center_x = col * self.hex_width + self.offset
            center_y = row * self.hex_height + offset_y + self.offset
            return center_x, center_y

        def draw(self):
            for y in range(self.rows):
                for x in range(self.cols):
                    center_x, center_y = self.calculate_center(x, y)
                    if self.state[y][x] == 1:
                        self.draw_hexagon(center_x, center_y, self.size, color=1)
                    else:
                        self.draw_hexagon(center_x, center_y, self.size)
                        # Desenhar um hexágono menor no centro
                        self.draw_hexagon(center_x, center_y, self.size * 0.29, math.pi * 2 / 12, self.colors)

        def draw_cell(self, cell):
            """
            Este método desenha um caminho do centro do hexágono até a borda do hexágono.
            O caminho é desenhado apenas se a célula estiver colapsada.
            Pode ser desenhadas 0 a 6 linhas, sendo elas 0 o topo.
            Cada edge representa uma direção e o valor 1 indica que a borda está conectada.
            """
            if not cell.collapsed:
                return

            center_x, center_y = self.calculate_center(cell.col, cell.row)
            size = self.size

            for i in [3, 5, 1, 2, 4, 0]:
                edge = cell.tile.edges[i]
                index = [4, -1, 0, 1, 2, 3][i]
                if edge == 1:
                    
                    # Calcular os ângulos dos dois vértices que formam a borda
                    angle1 = math.pi * 2 / 6 * index
                    angle2 = math.pi * 2 / 6 * ((index + 1) % 6)

                    # Calcular a posição dos dois vértices
                    vertex1_x = center_x + math.cos(angle1) * size
                    vertex1_y = center_y + math.sin(angle1) * size
                    vertex2_x = center_x + math.cos(angle2) * size
                    vertex2_y = center_y + math.sin(angle2) * size

                    # Calcular a posição do ponto médio da borda
                    edge_x = (vertex1_x + vertex2_x) / 2
                    edge_y = (vertex1_y + vertex2_y) / 2

                    # Definir as cores das linhas
                    color = [[0, 5, 8, 9], [3, 4, 6, 7], [1, 2, 10, 11]]
                    c1 = (
                        self.colors[2]
                        if (i + 6) in color[0]
                        else self.colors[0] if (i + 6) in color[1] else self.colors[1]
                    )
                    c2 = (
                        self.colors[2]
                        if i in color[0]
                        else self.colors[0] if i in color[1] else self.colors[1]
                    )

                    # Draw parallel lines
                    self.draw_parallel_shapes(center_x, center_y, edge_x, edge_y, [c1, c2])

            return (f"{cell.col},{cell.row}", center_x, center_y)

        def draw_parallel_shapes(self, x, y, x1, y1, colors, angle=30, factor=-1):
            # Calcular o vetor perpendicular
            dx = x1 - x
            dy = y1 - y
            length = (dx**2 + dy**2) ** 0.5
            perp_x = -dy / length * self.size / 4
            perp_y = dx / length * self.size / 4

            # Calcular as novas posições para as linhas paralelas
            x2, y2 = x + perp_x, y + perp_y
            x3, y3 = x1 + perp_x, y1 + perp_y
            x4, y4 = x - perp_x, y - perp_y
            x5, y5 = x1 - perp_x, y1 - perp_y

            xi, yi = line_intersection(
                x, y, *get_rotation_in_line(x, y, x2, y2, angle * factor), x3, y3, x2, y2
            )

            # Desenhar a linha principal
            vertex_initial = [(x, y), (x1, y1), (x3, y3), (xi, yi)]

            self.draw_vertex(vertex_initial, colors[0])

            xin, yin = line_intersection(
                x, y, *get_rotation_in_line(x, y, x4, y4, -angle * factor), x5, y5, x4, y4
            )

            # Desenhar a forma paralela
            vertex_parallel = [(x, y), (x1, y1), (x5, y5), (xin, yin)]
            self.draw_vertex(vertex_parallel, colors[1])

        def draw_hexagon(self, x, y, size, rotation=0, colors=None, color=255):
            # Calcular os vértices do hexágono
            vertices = []
            for i in range(6):
                angle = (math.pi * 2 / 6 * i) + rotation
                vx = x + math.cos(angle) * size
                vy = y + math.sin(angle) * size
                vertices.append((vx, vy))

            # Desenhar os losângulos
            if colors and len(colors) >= 3:
                for i in [-2, 0, 2]:
                    self.draw_vertex([
                        (x, y),
                        (vertices[i - 1][0], vertices[i - 1][1]),
                        (vertices[i][0], vertices[i][1]),
                        (vertices[i + 1][0], vertices[i + 1][1]),
                    ], colors[i])
            else:
                self.draw_map(vertices, color)

            return vertices

    from dataclasses import dataclass, field
    from functools import cached_property
    from itertools import product
    import random

    @dataclass
    class Tile:
        """
        Esta classe representa uma imagem de tile do py5 com suas bordas de possíveis conexões.
        A lista de bordas (edges) representa os tipos possíveis de conexão entre este tile e seus vizinhos.
        A posição da conexão na lista de bordas indica a orientação delas.
        """
        edges: list
        
        def get_side(self, side):
            return self.edges[side]

    @dataclass
    class Cell:
        col: int
        row: int
        dim: tuple[int, int]
        border: bool = False
        tile: Tile = field(default=None, init=False)  
        state: list = field(default_factory=lambda: [None, None, None, None, None, None])
        cases: list = field(default_factory=lambda: [0, 1])
                
        def __post_init__(self):
            if self.border:
                self.update_border_state()
                

        @property
        def collapsed(self):
            return self.tile is not None

        def collapse(self):
            edges = []
            for state in self.state:
                if state is not None:
                    edges.append(state)
                else:
                    edges.append(random.choice(self.cases))
            self.tile = Tile(edges)    

        @property
        def entropy(self):
            if self.collapsed:
                return 0
            return len([state for state in self.state if state is not None]) ** len(self.cases)

        def update_border_state(self):
            if self.col == 0:
                self.state[4] = 0
                self.state[5] = 0
            if self.col == self.dim[0] - 1:
                self.state[1] = 0
                self.state[2] = 0
            if self.row == 0:
                self.state[0] = 0
                if self.col % 2 == 0:
                    self.state[1] = 0
                    self.state[5] = 0
            if self.row == self.dim[1] - 1:
                self.state[3] = 0
                if self.col % 2 != 0:
                    self.state[2] = 0
                    self.state[4] = 0        
                

        def update_state(self, neighbor_number, value):
            index = [3,4,5,0,1,2][neighbor_number]
            self.state[index] = value


    @dataclass
    class HexWaveFunctionCollapseGrid:
        """
        Classe WaveFunctionCollapseGrid
        ===============================
        Classe para representar uma grade que será populada colapsando suas células.
        Atributos:
        ----------
        tiles : list
            Lista de tiles disponíveis para a grade.
        dim : int
            Dimensão da grade.
        pending_cells : list[Cell]
            Lista de células pendentes que ainda não foram colapsadas.
        Métodos:
        --------
        __post_init__():
            Inicializa a lista de células pendentes com uma cópia das células e embaralha a lista.
        w():
            Retorna a largura de cada célula na grade.
        h():
            Retorna a altura de cada célula na grade.
        cells():
            Retorna uma lista de células inicializadas com todas as tiles possíveis.
        start():
            Inicia o algoritmo escolhendo uma célula aleatória e colapsando-a.
        collapse_cell(cell):
            Colapsa a célula especificada, remove-a da lista de células pendentes e atualiza as opções das células vizinhas.
        get_neighbors(cell):
            Dada uma célula, retorna a lista de vizinhos que ainda não foram colapsados.
        complete():
            Retorna True se todas as células foram colapsadas, caso contrário, False.
        collapse():
            Obtém a próxima célula pendente com a menor entropia e a colapsa.
        draw():
            Desenha a grade, exibindo as imagens das células colapsadas.
        Class to represent a grid which will be populated by collapsing their cells.
        """

        dim: tuple[int, int]
        pending_cells: list[Cell] = field(default=list, init=False)
        draw_cell: callable
        border: bool = False
        
        def __post_init__(self):        
            self.pending_cells = self.cells[:] 
            random.shuffle(self.pending_cells)

        @cached_property
        def cells(self):
            return [
                Cell(col=i, row=j, dim=self.dim, border=self.border) 
                for i, j in product(range(0, self.dim[0]), range(0, self.dim[1]))
            ]

        def start(self):
            """
            To start the algorithm, we pick any random cell and collapse it since all of them have the
            same set of possible tiles.
            """
            cell = random.choice(self.cells)
            self.collapse_cell(cell)

        def collapse_cell(self, cell: Cell):
            cell.collapse()
            self.pending_cells.remove(cell)
            for index, neighbor_cell in self.get_neighbors(cell):
                neighbor_cell.update_state(neighbor_number=index, value=cell.tile.get_side(index))

        def get_neighbors(self, cell: Cell):
            """
            Given a cell, return its list of neighbors which still weren't collapsed.
            """
            i, j = cell.col, cell.row
            positions = [
                (i, j - 1),
                (i + 1, j - 1) if i % 2 == 0 else(i + 1, j) ,
                (i + 1, j) if i % 2 == 0 else (i + 1, j + 1),
                (i, j + 1),
                (i - 1, j) if i % 2 == 0 else (i - 1, j + 1),
                (i - 1, j - 1) if i % 2 == 0 else (i - 1, j),
            ]

            #       1,0  
            # 0,1 - 1,1 - 2,1
            # 0,2 - 1,2 - 2,2
            
            #        2,1
            #  1,1 - 2,2 - 3,1
            #  1,2 - 2,3 - 3,2
            
            neighbors = [
                (index, c) for index, pos in enumerate(positions)
                for c in self.pending_cells if (c.col, c.row) == pos
            ]
            return neighbors

        @property
        def complete(self):
            return not self.pending_cells

        def collapse(self):
            if not self.pending_cells:
                return  # Se não houver células pendentes, retorne imediatamente

            next_cell = sorted(self.pending_cells, key=lambda c: c.entropy)[0]
            # Resto do código da função collapse
            self.collapse_cell(next_cell)

        def draw(self):
            for cell in self.cells:
                if cell.collapsed:
                    self.draw_cell(cell)

    py5.iniciar_animacao(setup, draw)
      </script>
</body>
</html>